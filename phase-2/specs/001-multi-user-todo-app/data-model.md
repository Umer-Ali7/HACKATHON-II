# Data Model: Hackathon Todo

**Feature**: 001-multi-user-todo-app
**Date**: 2026-01-06
**Purpose**: Define database schema and entity relationships

## Overview

The application uses two primary entities: **User** (managed by Better Auth) and **Task** (application-managed). The data model enforces strict user isolation through foreign key relationships and indexes optimized for filtering operations.

## Entity Relationship Diagram

```
┌─────────────────┐          ┌──────────────────┐
│     User        │          │      Task        │
├─────────────────┤          ├──────────────────┤
│ id (PK)         │──────────│ user_id (FK)     │
│ email           │   1:N    │ id (PK)          │
│ name            │          │ title            │
│ password_hash   │          │ description      │
│ created_at      │          │ completed        │
│                 │          │ created_at       │
│                 │          │ updated_at       │
└─────────────────┘          └──────────────────┘
```

**Relationship**: One user has many tasks. Each task belongs to exactly one user.

## Entities

### 1. User Entity

**Managed By**: Better Auth (automatic table creation)

**Table Name**: `users`

**Purpose**: Store user account information for authentication and task ownership.

#### Fields

| Field Name | Type | Constraints | Description |
|------------|------|-------------|-------------|
| id | TEXT | PRIMARY KEY | Unique user identifier (UUID generated by Better Auth) |
| email | TEXT | NOT NULL, UNIQUE | User's email address for login |
| name | TEXT | NULLABLE | User's display name (optional) |
| password_hash | TEXT | NOT NULL | Bcrypt hashed password (managed by Better Auth) |
| email_verified | BOOLEAN | DEFAULT FALSE | Email verification status (not used in Phase II) |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Account creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last account update timestamp |

#### Indexes

- PRIMARY KEY on `id`
- UNIQUE INDEX on `email` (enforces one account per email)

#### Validation Rules

- Email must be valid email format (validated by Better Auth)
- Password must be at least 8 characters (validated by Better Auth)
- Email must be unique across all users

#### Notes

- Better Auth creates this table automatically on first startup
- Password is never stored in plaintext (bcrypt hash with salt)
- `id` field uses TEXT to accommodate Better Auth's UUID format

---

### 2. Task Entity

**Managed By**: Application (SQLModel + Alembic migrations)

**Table Name**: `tasks`

**Purpose**: Store todo items created by users with completion tracking.

#### Fields

| Field Name | Type | Constraints | Description |
|------------|------|-------------|-------------|
| id | INTEGER | PRIMARY KEY, SERIAL | Auto-incrementing unique task identifier |
| user_id | TEXT | NOT NULL, FOREIGN KEY (users.id) | Owner of this task |
| title | VARCHAR(200) | NOT NULL | Task title (required) |
| description | TEXT | NULLABLE | Optional detailed description |
| completed | BOOLEAN | NOT NULL, DEFAULT FALSE | Completion status |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Task creation timestamp (UTC) |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last modification timestamp (UTC) |

#### Relationships

- `user_id` → `users.id` (FOREIGN KEY with CASCADE delete)

#### Indexes

| Index Name | Columns | Type | Purpose |
|------------|---------|------|---------|
| PRIMARY | id | B-tree | Unique identification |
| idx_tasks_user_id | user_id | B-tree | Filter tasks by owner (CRITICAL for user isolation) |
| idx_tasks_completed | completed | B-tree | Filter tasks by status |
| idx_tasks_user_completed | user_id, completed | B-tree (composite) | Combined filter (user + status) |
| idx_tasks_created_at | created_at DESC | B-tree | Sort by creation date (newest first) |

#### Validation Rules

| Rule | Validation Level | Enforcement |
|------|------------------|-------------|
| Title required | Frontend + Backend + Database | NOT NULL constraint |
| Title max 200 chars | Frontend + Backend + Database | VARCHAR(200) |
| Description max 1000 chars | Frontend + Backend | Application-level check |
| Completed is boolean | Backend + Database | BOOLEAN type |
| user_id must exist | Database | FOREIGN KEY constraint |
| user_id cannot be changed | Backend | Immutable after creation |
| created_at immutable | Backend | No update allowed |

#### State Transitions

```
┌─────────────┐
│  Created    │  Initial state when task is created
│ completed:  │
│   false     │
└──────┬──────┘
       │
       │ User clicks checkbox
       ▼
┌─────────────┐
│  Completed  │  User marks task as done
│ completed:  │
│   true      │
└──────┬──────┘
       │
       │ User clicks checkbox again
       ▼
┌─────────────┐
│  Incomplete │  User marks task as not done
│ completed:  │
│   false     │
└─────────────┘
```

**Valid Transitions**:
- false → true (mark complete)
- true → false (mark incomplete)

**Notes**:
- Tasks can toggle between completed/incomplete unlimited times
- `updated_at` is set to current timestamp on every toggle
- Deletion is permanent (no soft delete)

## Database Constraints

### Foreign Key Constraints

```sql
ALTER TABLE tasks
ADD CONSTRAINT fk_tasks_user_id
FOREIGN KEY (user_id)
REFERENCES users(id)
ON DELETE CASCADE;
```

**ON DELETE CASCADE**: When a user is deleted, all their tasks are automatically deleted.

**Rationale**: User data isolation principle - no orphaned tasks from deleted users.

### Check Constraints

```sql
ALTER TABLE tasks
ADD CONSTRAINT check_title_length
CHECK (length(title) > 0 AND length(title) <= 200);

ALTER TABLE tasks
ADD CONSTRAINT check_description_length
CHECK (description IS NULL OR length(description) <= 1000);
```

## SQLModel Implementation

### User Model (Reference Only)

```python
# app/models/user.py
# Better Auth manages this table - included for reference only

from sqlmodel import SQLModel, Field
from datetime import datetime

class User(SQLModel, table=True):
    __tablename__ = "users"

    id: str = Field(primary_key=True)
    email: str = Field(unique=True, index=True)
    name: str | None = None
    password_hash: str
    email_verified: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

### Task Model (Application-Managed)

```python
# app/models/task.py
from sqlmodel import SQLModel, Field, Index
from datetime import datetime

class Task(SQLModel, table=True):
    __tablename__ = "tasks"

    id: int | None = Field(default=None, primary_key=True)
    user_id: str = Field(foreign_key="users.id", index=True)
    title: str = Field(max_length=200)
    description: str | None = Field(default=None, max_length=1000)
    completed: bool = Field(default=False, index=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    __table_args__ = (
        Index("idx_tasks_user_completed", "user_id", "completed"),
    )
```

## Pydantic Schemas (API Layer)

### Task Schemas

```python
# app/schemas/task.py
from pydantic import BaseModel, Field, field_validator
from datetime import datetime

class TaskCreate(BaseModel):
    """Request body for creating a new task"""
    title: str = Field(..., min_length=1, max_length=200)
    description: str | None = Field(None, max_length=1000)

    @field_validator('title')
    def title_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError('Title cannot be empty or whitespace')
        return v.strip()

class TaskUpdate(BaseModel):
    """Request body for updating a task"""
    title: str | None = Field(None, min_length=1, max_length=200)
    description: str | None = Field(None, max_length=1000)

    @field_validator('title')
    def title_must_not_be_empty(cls, v):
        if v is not None and not v.strip():
            raise ValueError('Title cannot be empty or whitespace')
        return v.strip() if v else None

class TaskResponse(BaseModel):
    """Response body for task operations"""
    id: int
    user_id: str
    title: str
    description: str | None
    completed: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True  # Enable ORM mode for SQLModel
```

## Migration Strategy

### Initial Migration (Alembic)

```python
# alembic/versions/001_create_tasks_table.py
def upgrade():
    op.create_table(
        'tasks',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('user_id', sa.Text(), nullable=False),
        sa.Column('title', sa.String(length=200), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('completed', sa.Boolean(), server_default='false', nullable=False),
        sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    )
    op.create_index('idx_tasks_user_id', 'tasks', ['user_id'])
    op.create_index('idx_tasks_completed', 'tasks', ['completed'])
    op.create_index('idx_tasks_user_completed', 'tasks', ['user_id', 'completed'])

def downgrade():
    op.drop_index('idx_tasks_user_completed', table_name='tasks')
    op.drop_index('idx_tasks_completed', table_name='tasks')
    op.drop_index('idx_tasks_user_id', table_name='tasks')
    op.drop_table('tasks')
```

## Performance Considerations

### Query Performance

**Most Common Query**: List user's tasks filtered by status
```sql
SELECT * FROM tasks
WHERE user_id = ? AND completed = ?
ORDER BY created_at DESC;
```

**Index Used**: `idx_tasks_user_completed` (composite index)

**Expected Performance**: <10ms for up to 10,000 tasks per user

### Index Strategy

1. **user_id index**: Mandatory for user isolation (filters every query)
2. **completed index**: Supports status filtering (All/Pending/Completed)
3. **Composite index (user_id, completed)**: Optimizes combined filter
4. **created_at index**: Supports sorting by newest first

### Connection Pooling

Neon Serverless handles connection pooling automatically:
- No client-side pool configuration needed
- Use `NullPool` in SQLAlchemy to avoid double-pooling
- Neon scales connections based on load

## Data Integrity Rules

### Critical Invariants

1. **User Isolation**: `user_id` MUST be filtered in every task query
2. **No Orphaned Tasks**: CASCADE delete ensures tasks removed with user
3. **Title Required**: Title cannot be NULL or empty string
4. **Immutable Fields**: `created_at` and `user_id` cannot change after creation
5. **Timestamp Auto-Update**: `updated_at` must reflect current time on modification

### Enforcement Levels

- **Database**: Foreign keys, NOT NULL, CHECK constraints
- **Backend**: Pydantic validation, business logic
- **Frontend**: Form validation, TypeScript types

## TypeScript Type Definitions

```typescript
// frontend/lib/types.ts
export interface Task {
  id: number;
  user_id: string;
  title: string;
  description: string | null;
  completed: boolean;
  created_at: string;  // ISO 8601 datetime
  updated_at: string;  // ISO 8601 datetime
}

export interface TaskCreate {
  title: string;
  description?: string;
}

export interface TaskUpdate {
  title?: string;
  description?: string;
}
```

---

## Summary

The data model implements strict user isolation through:
- Foreign key relationships enforcing ownership
- Indexes optimized for user-filtered queries
- Multi-layer validation (DB, backend, frontend)
- Cascade delete maintaining data integrity

All design decisions align with constitution requirements for type safety, database as source of truth, and user data isolation.
